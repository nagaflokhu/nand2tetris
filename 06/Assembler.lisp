#!/usr/local/bin/clisp
; Built-in symbols
(setf symbols
      '(("SP" . 0) ("LCL" . 1) ("ARG" . 2) ("THIS" . 3) ("THAT" . 4)
        ("R0" . 0) ("R1" . 1) ("R2" . 2) ("R3" . 3) ("R4" . 4) ("R5" . 5)
        ("R6" . 6) ("R7" . 7) ("R8" . 8) ("R9" . 9) ("R10" . 10)
        ("R11" . 11) ("R12" . 12) ("R13" . 13) ("R14" . 14) ("R15" . 15)
        ("SCREEN" . 16384) ("KBD" . 24576)))

(setf jumps
      '(("JGT" . "001") ("JEQ" . "010") ("JGE" . "011") ("JLT" . "100")
        ("JNE" . "101") ("JLE" . "110") ("JMP" . "111")))

(setf dests
      '(("M" . "001") ("D" . "010") ("MD" . "011") ("DM" . "011")
        ("A" . "100") ("AM" . "101") ("MA" . "101") ("AD" . "110")
        ("DA" . "110") ("AMD" . "111") ("ADM" . "111") ("MDA" . "111")
        ("MAD" . "111") ("DMA" . "111") ("DAM" . "111")))

(defun remove-comments (code)
    (let ((new nil))
         (do ((line (read-line code nil) (read-line code nil)))
             ((null line) new)
             (let ((pos (search "//" line)))
                  (cond ((eql pos nil)
                         (setf new (concatenate 'string new line '(#\newline))))
                        (t (setf new (concatenate 'string new
                                                  (subseq line 0 pos) '(#\newline)))))))
          (make-string-input-stream new)))

(defun remove-blanks (code)
    (let ((new nil))
         (do ((line (read-line code nil) (read-line code nil)))
             ((null line) new)
             (unless (string= line "")
                 (setf new (concatenate 'string new (remove #\space line)
                                        '(#\newline)))))
         (make-string-input-stream new)))

(defun find-symbols (code symbols)
    ; a symbol will either occur in parentheses or preceded
    ; by an @ character, so check for both and check that
    ; the @ character is not followed by an address
    ; variable symbols contains the symbols we already know
    (do ((line (read-line code nil) (read-line code nil))
         (counter 0)
         (var-mem-pos 16))
        ((null line) symbols)
        (cond ((char= (char line 0) #\()
               (let* ((pos (search ")" line))
                      (var-name (subseq line 1 pos))
                      (entry (cons (subseq line 1 pos) counter)))
                     (cond ((eql (assoc var-name symbols) nil)
                           (push (cons (subseq line 1 pos) counter) symbols)
                           (setf counter (1+ counter))))))
              ((char= (char line 0) #\@)
               (let ((var-name (subseq line 1)))
                    (unless (integerp var-name)
                         (let ((cell (assoc var-name symbols)))
                              (cond ((eql cell nil)
                                     (push (cons var-name var-mem-pos) symbols)
                                     (setf var-mem-pos (1+ var-mem-pos))))))))
              (t (setf counter (1+ counter))))))
               ; the rest of the line can either be a number or a symbol
               ; if it's a symbol that has not been encountered, create it
               ; and assign location in memory

(defun find-labels (code symbols)
    (do ((line (read-line code nil) (read-line code nil))
         (counter 0))
        ((null line) (file-position code 0) symbols)
        (cond ((char= (char line 0) #\()
               (let* ((pos (search ")" line))
                      (var-name (subseq line 1 pos))
                      (entry (cons (subseq line 1 pos) counter)))
                     (cond ((eql (assoc var-name symbols :test #'string=) nil)
                            (push entry symbols))
                           (t (setf counter (1+ counter))))))
              (t (setf counter (1+ counter))))))

(defun find-vars (code symbols)
    (do ((line (read-line code nil) (read-line code nil))
         (var-mem-pos 16))
        ((null line) (file-position code 0) symbols)
        (cond ((char= (char line 0) #\@)
               (let* ((var-name (subseq line 1))
                      (entry (assoc var-name symbols :test #'string=)))
                     (cond ((and (eql entry nil)
                                 (not (ignore-errors (integerp (read-from-string var-name)))))
                           (push (cons var-name var-mem-pos) symbols)
                           (setf var-mem-pos (1+ var-mem-pos)))))))))

(defun gen-code (code symbols)
    (let ((final nil))
        (do ((line (read-line code nil) (read-line code nil)))
            ((null line) final)
            (let ((char1 (char line 0)))
                 (cond ((char= char1 #\@)
                        (let* ((sym-name (subseq line 1))
                               (num? (ignore-errors (integerp (read-from-string sym-name)))))
                              (if num?
                                  (setf address (read-from-string sym-name))
                                  (setf address (cdr (assoc sym-name symbols :test #'string=))))
                              (setf bin-code (format nil "~16,'0B" address) 
                                    final (concatenate 'string final bin-code '(#\newline)))))
                       ((or (char= char1 #\D)
                            (char= char1 #\M)
                            (char= char1 #\A)
                            (digit-char-p char1))
                        (setf final (concatenate 'string final
                                                 (parse-c-instruction line jumps dests)))))))))
    
(defun parse-c-instruction (line jumps dests)
    (let ((prefix "111")
          (jump? (search ";" line))
          (dest? (search "=" line)))
         (cond (jump? 
               (let ((type (subseq line (1+ jump?))))
                    (setf j (cdr (assoc type jumps :test #'string=)))))
               (t (setf j "000")))
         (cond (dest?
               (let ((type (subseq line 0 dest?)))
                    (setf d (cdr (assoc type dests :test #'string=)))))
               (t (setf d "000")))
         (if jump?
             (setf end jump?)
             (setf end (length line)))
         (if dest?
             (setf begin (1+ dest?))
             (setf begin 0))
         (let ((0? (search "0" line :start2 begin :end2 end))
               (1? (search "1" line :start2 begin :end2 end))
               (M1? (search "-1" line :start2 begin :end2 end))
               (D? (search "D" line :start2 begin :end2 end))
               (A? (search "A" line :start2 begin :end2 end))
               (M? (search "M" line :start2 begin :end2 end))
               (!D? (search "!D" line :start2 begin :end2 end))
               (!A? (search "!A" line :start2 begin :end2 end))
               (!M? (search "!M" line :start2 begin :end2 end))
               (MD? (search "-D" line :start2 begin :end2 end))
               (MA? (search "-A" line :start2 begin :end2 end))
               (MM? (search "-M" line :start2 begin :end2 end))
               (D+1? (search "D+1" line :start2 begin :end2 end))
               (A+1? (search "A+1" line :start2 begin :end2 end))
               (M+1? (search "M+1" line :start2 begin :end2 end))
               (D-1? (search "D-1" line :start2 begin :end2 end))
               (A-1? (search "A-1" line :start2 begin :end2 end))
               (M-1? (search "M-1" line :start2 begin :end2 end))
               (D+A? (search "D+A" line :start2 begin :end2 end))
               (D+M? (search "D+M" line :start2 begin :end2 end))
               (D-A? (search "D-A" line :start2 begin :end2 end))
               (D-M? (search "D-M" line :start2 begin :end2 end))
               (A-D? (search "A-D" line :start2 begin :end2 end))
               (M-D? (search "M-D" line :start2 begin :end2 end))
               (D&A? (search "D&A" line :start2 begin :end2 end))
               (D&M? (search "D&M" line :start2 begin :end2 end))
               (DorA? (search "D|A" line :start2 begin :end2 end))
               (DorM? (search "D|M" line :start2 begin :end2 end)))
              (cond (DorA? (setf c "0010101"))
                    (DorM? (setf c "1010101"))
                    (D&M? (setf c "1000000"))
                    (D&A? (setf c "0000000"))
                    (A-D? (setf c "0000111"))
                    (M-D? (setf c "1000111"))
                    (D-A? (setf c "0010011"))
                    (D-M? (setf c "1010011"))
                    (D+A? (setf c "0000010"))
                    (D+M? (setf c "1000010"))
                    (A-1? (setf c "0110010"))
                    (M-1? (setf c "1110010"))
                    (D-1? (setf c "0001110"))
                    (A+1? (setf c "0110111"))
                    (M+1? (setf c "1110111"))
                    (D+1? (setf c "0011111"))
                    (MA? (setf c "0110011"))
                    (MM? (setf c "1110011"))
                    (MD? (setf c "0001111"))
                    (!A? (setf c "0110001"))
                    (!M? (setf c "1110001"))
                    (!D? (setf c "0001101"))
                    (A? (setf c "0110000"))
                    (M? (setf c "1110000"))
                    (D? (setf c "0001100"))
                    (M1? (setf c "0111010"))
                    (1? (setf c "0111111"))
                    (0? (setf c "0101010")))
              (concatenate 'string prefix c d j '(#\newline)))))

(let* ((full-path (car EXT:*ARGS*))
       (pos (search ".asm" full-path)))
      ; if there is not .asm in the path, we will presume there has been
      ; a mistake and do nothing
      (unless (eql pos nil)
          (with-open-file (code full-path)
              (setf new (remove-comments code) new (remove-blanks new)
                    symbols (find-labels new symbols)
                    symbols (find-vars new symbols)
                    new (gen-code new symbols)))
          (with-open-file (code (concatenate 'string (subseq full-path 0 pos)
                                             ".hack") :direction :output
                                :if-exists :supersede)
              (format code new))))